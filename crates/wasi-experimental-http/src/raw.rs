
//
// This file was automatically generated by witx-codegen - Do not edit manually.
//

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Error {
    WasiError(i32),
}
impl std::error::Error for Error {}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::WasiError(e) => write!(f, "Wasi error {}", e),
        }
    }
}

pub type WasiHandle = i32;
pub type Char8 = u8;
pub type Char32 = u32;
pub type WasiPtr<T> = *const T;
pub type WasiMutPtr<T> = *mut T;
pub type WasiStringBytesPtr = WasiPtr<Char8>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct WasiSlice<T> {
    ptr: WasiPtr<T>,
    len: usize,
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct WasiMutSlice<T> {
    ptr: WasiMutPtr<T>,
    len: usize,
}

impl<T> WasiSlice<T> {
    pub fn as_slice(&self) -> &[T] {
        unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
    }

    pub fn from_slice(&self, slice: &[T]) -> Self {
        WasiSlice {
            ptr: slice.as_ptr() as _,
            len: slice.len(),
        }
    }
}

impl<T> WasiMutSlice<T> {
    pub fn as_slice(&self) -> &[T] {
        unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
    }

    pub fn as_mut_slice(&self) -> &mut [T] {
        unsafe { std::slice::from_raw_parts_mut(self.ptr, self.len) }
    }

    pub fn from_slice(&self, slice: &[T]) -> Self {
        WasiMutSlice {
            ptr: slice.as_ptr() as _,
            len: slice.len(),
        }
    }

    pub fn from_mut_slice(&self, slice: &mut [T]) -> Self {
        WasiMutSlice {
            ptr: slice.as_mut_ptr(),
            len: slice.len(),
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct WasiString {
    ptr: WasiStringBytesPtr,
    len: usize,
}

impl<T: AsRef<str>> From<T> for WasiString {
    fn from(s: T) -> Self {
        let s = s.as_ref();
        WasiString {
            ptr: s.as_ptr() as _,
            len: s.len(),
        }
    }
}

impl WasiString {
    pub fn as_str(&self) -> Result<&str, std::str::Utf8Error> {
        std::str::from_utf8(unsafe { std::slice::from_raw_parts(self.ptr, self.len) })
    }

    pub fn as_slice(&self) -> &[u8] {
        unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
    }

    pub fn from_slice(&self, slice: &[u8]) -> Self {
        WasiString {
            ptr: slice.as_ptr() as _,
            len: slice.len(),
        }
    }
}

/// ---------------------- Module: [wasi_experimental_http] ----------------------

pub type HttpError = u32;

#[allow(non_snake_case)]
pub mod HTTP_ERROR {
    use super::HttpError;
    pub const SUCCESS: HttpError = 0;
    pub const INVALID_HANDLE: HttpError = 1;
    pub const MEMORY_NOT_FOUND: HttpError = 2;
    pub const MEMORY_ACCESS_ERROR: HttpError = 3;
    pub const BUFFER_TOO_SMALL: HttpError = 4;
    pub const HEADER_NOT_FOUND: HttpError = 5;
    pub const UTF_8_ERROR: HttpError = 6;
    pub const DESTINATION_NOT_ALLOWED: HttpError = 7;
    pub const INVALID_METHOD: HttpError = 8;
    pub const INVALID_ENCODING: HttpError = 9;
    pub const INVALID_URL: HttpError = 10;
    pub const REQUEST_ERROR: HttpError = 11;
    pub const RUNTIME_ERROR: HttpError = 12;
    pub const TOO_MANY_SESSIONS: HttpError = 13;
}

/// HTTP status code
pub type StatusCode = u16;

/// An HTTP body being sent
pub type OutgoingBody = WasiSlice<u8>;

/// Buffer for an HTTP body being received
pub type IncomingBody = WasiMutSlice<u8>;

/// A response handle
pub type ResponseHandle = WasiHandle;

/// Buffer to store a header value
pub type HeaderValueBuf = WasiMutSlice<u8>;

/// Number of bytes having been written
pub type WrittenBytes = usize;

/// Send a request
pub fn req(
    url_ptr: WasiPtr<Char8>,
    url_len: usize,
    method_ptr: WasiPtr<Char8>,
    method_len: usize,
    headers_ptr: WasiPtr<Char8>,
    headers_len: usize,
    body_ptr: WasiPtr<u8>,
    body_len: usize,
    config_ptr: WasiPtr<u8>,
    config_len: usize,
) -> Result<(StatusCode, ResponseHandle), Error> {
    #[link(wasm_import_module = "wasi_experimental_http")]
    extern "C" {
        fn req(
            url_ptr: WasiPtr<Char8>,
            url_len: usize,
            method_ptr: WasiPtr<Char8>,
            method_len: usize,
            headers_ptr: WasiPtr<Char8>,
            headers_len: usize,
            body_ptr: WasiPtr<u8>,
            body_len: usize,
            config_ptr: WasiPtr<u8>,
            config_len: usize,
            result_0_ptr: WasiMutPtr<StatusCode>,
            result_1_ptr: WasiMutPtr<ResponseHandle>,
        ) -> HttpError;
    }
    let mut result_0_ptr = std::mem::MaybeUninit::uninit();
    let mut result_1_ptr = std::mem::MaybeUninit::uninit();
    let res = unsafe { req(
        url_ptr,
        url_len,
        method_ptr,
        method_len,
        headers_ptr,
        headers_len,
        body_ptr,
        body_len,
        config_ptr,
        config_len,
        result_0_ptr.as_mut_ptr(),
        result_1_ptr.as_mut_ptr(),
    )};
    if res != 0 {
        return Err(Error::WasiError(res as _));
    }
    Ok(unsafe { (result_0_ptr.assume_init(), result_1_ptr.assume_init()) })
}

/// Close a request handle
pub fn close(
    response_handle: ResponseHandle,
) -> Result<(), Error> {
    #[link(wasm_import_module = "wasi_experimental_http")]
    extern "C" {
        fn close(
            response_handle: ResponseHandle,
        ) -> HttpError;
    }
    let res = unsafe { close(
        response_handle,
    )};
    if res != 0 {
        return Err(Error::WasiError(res as _));
    }
    Ok(())
}

/// Get the value associated with a header
pub fn header_get(
    response_handle: ResponseHandle,
    header_name_ptr: WasiPtr<Char8>,
    header_name_len: usize,
    header_value_buf_ptr: WasiMutPtr<u8>,
    header_value_buf_len: usize,
) -> Result<WrittenBytes, Error> {
    #[link(wasm_import_module = "wasi_experimental_http")]
    extern "C" {
        fn header_get(
            response_handle: ResponseHandle,
            header_name_ptr: WasiPtr<Char8>,
            header_name_len: usize,
            header_value_buf_ptr: WasiMutPtr<u8>,
            header_value_buf_len: usize,
            result_ptr: WasiMutPtr<WrittenBytes>,
        ) -> HttpError;
    }
    let mut result_ptr = std::mem::MaybeUninit::uninit();
    let res = unsafe { header_get(
        response_handle,
        header_name_ptr,
        header_name_len,
        header_value_buf_ptr,
        header_value_buf_len,
        result_ptr.as_mut_ptr(),
    )};
    if res != 0 {
        return Err(Error::WasiError(res as _));
    }
    Ok(unsafe { result_ptr.assume_init() })
}

/// Get the entire response header map
pub fn headers_get_all(
    response_handle: ResponseHandle,
    header_value_buf_ptr: WasiMutPtr<u8>,
    header_value_buf_len: usize,
) -> Result<WrittenBytes, Error> {
    #[link(wasm_import_module = "wasi_experimental_http")]
    extern "C" {
        fn headers_get_all(
            response_handle: ResponseHandle,
            header_value_buf_ptr: WasiMutPtr<u8>,
            header_value_buf_len: usize,
            result_ptr: WasiMutPtr<WrittenBytes>,
        ) -> HttpError;
    }
    let mut result_ptr = std::mem::MaybeUninit::uninit();
    let res = unsafe { headers_get_all(
        response_handle,
        header_value_buf_ptr,
        header_value_buf_len,
        result_ptr.as_mut_ptr(),
    )};
    if res != 0 {
        return Err(Error::WasiError(res as _));
    }
    Ok(unsafe { result_ptr.assume_init() })
}

/// Fill a buffer with the streamed content of a response body
pub fn body_read(
    response_handle: ResponseHandle,
    body_buf_ptr: WasiMutPtr<u8>,
    body_buf_len: usize,
) -> Result<WrittenBytes, Error> {
    #[link(wasm_import_module = "wasi_experimental_http")]
    extern "C" {
        fn body_read(
            response_handle: ResponseHandle,
            body_buf_ptr: WasiMutPtr<u8>,
            body_buf_len: usize,
            result_ptr: WasiMutPtr<WrittenBytes>,
        ) -> HttpError;
    }
    let mut result_ptr = std::mem::MaybeUninit::uninit();
    let res = unsafe { body_read(
        response_handle,
        body_buf_ptr,
        body_buf_len,
        result_ptr.as_mut_ptr(),
    )};
    if res != 0 {
        return Err(Error::WasiError(res as _));
    }
    Ok(unsafe { result_ptr.assume_init() })
}

